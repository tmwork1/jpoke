# Copilot 指示

## プロジェクト概要
- jpoke はポケモンシングルバトル対戦シミュレータで、戦闘ロジックの開発に使用される
- ポケモンの利用規約に抵触する可能性があるため、AI ボットの開発は保留中

## アーキテクチャ

### イベント駆動パターン
- [core/event.py](src/jpoke/core/event.py) で `EventManager` が中核。Battle の各フェーズでイベント発火
- 特性・アイテム・技の効果は `Handler` 登録で実装。同期実行、優先度制御あり
- `EventContext` で source/target/attacker/defender のロール管理
- **Handler の構造**:
  - **func**: 実行する関数（HandlerReturn を返す）
  - **subject_spec**: `"role:side"` 形式で発動条件を指定
    - role: "source", "target", "attacker", "defender"
    - side: "self"（自分側）または "foe"（相手側）
  - **source_type**: "ability" | "item" | "move"（ハンドラの出典）
  - **log**: LogPolicy で自動ログ出力の制御（"always" | "on_success" | "on_failure" | "never"）
  - プロパティ `Handler.role`, `Handler.side` で分解取得可能

### HandlerReturn
- ハンドラ関数は `HandlerReturn` NamedTuple を返す（型チェック/自動ログに使用）
- `HandlerReturn(success: bool, value: Any = None, control: HandlerResult | None = None)`
  - success: 処理が成功したか
  - value: 後続の修正計算に使う値（ダメージ補正など）
  - control: イベント制御フラグ（STOP_HANDLER など）

### Handler 派生クラス
- [handlers/ability.py](src/jpoke/handlers/ability.py): `AbilityHandler` 継承で source_type="ability" + log="on_success" デフォルト
- [handlers/item.py](src/jpoke/handlers/item.py): `ItemHandler` 継承で source_type="item" + log="on_success" デフォルト
- data 配下では派生クラスを使用し、冗長な引数指定を削減

### 主要フロー
1. **Battle.execute()** → Players の選択受け取り → ターン実行
2. **ダメージ計算** - [core/damage.py](src/jpoke/core/damage.py) で種族値・努力値・ランク・修正を集約
3. **フィールド効果** - WeatherManager, TerrainManager, SideFieldManager で状態管理
4. **深いコピー** - Battle は deepcopy 対応（乱数隠蔽含む）

## 命名規則
### bool 型変数・メソッド
- **状態確認**: `is_` で始める（例: `is_active`, `is_floating()`, `is_trapped()`）
- **所有確認**: `has_` で始める（例: `has_type()`, `has_interrupt()`）
- **能力確認**: `can_` で始める（例: `can_terastallize()`）

### ハンドラ関数のパラメータ命名
- ロール/サイド指定: `xxx_spec` 形式（例: `target_spec`, `source_spec`）
- `RoleSpec` 型で常に `"role:side"` 形式（例: `"target:foe"`, `"source:self"`）
- [handlers/base.py](src/jpoke/handlers/base.py) の `resolve_role()` で解決

## 関連ファイル解読順序
1. [utils/types.py](src/jpoke/utils/types.py) - RoleSpec, EffectSource, LogPolicy などの型定義
2. [core/event.py](src/jpoke/core/event.py) - Handler, EventContext, EventManager
3. [core/battle.py](src/jpoke/core/battle.py) - Battle クラスと turn ループ
4. [data/models.py](src/jpoke/data/models.py) - AbilityData, ItemData, MoveData などの構造定義
5. [handlers/ability.py](src/jpoke/handlers/ability.py) + [handlers/item.py](src/jpoke/handlers/item.py) - Handler 派生と汎用関数

## Handler 定義パターン（data/ 配下）

### AbilityHandler の使用例
```python
from jpoke.handlers import ability as h

"いかく": AbilityData(
    handlers={
        Event.ON_SWITCH_IN: h.AbilityHandler(
            partial(common.modify_stat, stat="A", v=-1, target_spec="source:foe", source_spec="source:self"),
            subject_spec="source:self",
            log="always",  # デフォルトは "on_success"（明示的に指定する場合のみ）
        )
    }
),
```

### ItemHandler の使用例
```python
from jpoke.handlers import item as h

"いのちのたま": ItemData(
    handlers={
        Event.ON_HIT: h.ItemHandler(
            h.いのちのたま,
            subject_spec="attacker:self",
            # log と source_type は自動設定（on_success, item）
        )
    }
),
```

### Lambda ハンドラの使用例
```python
Event.ON_HIT: h.ItemHandler(
    lambda btl, ctx, v: HandlerReturn(base.modify_hp(btl, ctx.attacker, r=-1/4)),
    subject_spec="attacker:self",
),
```

## テスト実行
```bash
python tests/run_tests.py              # 全テスト実行
python tests/run_tests.py "move_*.py"  # パターンマッチ
```
- [tests/run_tests.py](tests/run_tests.py) は async テストランナー
- 各ファイルで `test()` 関数を定義

## 開発時のポイント
- **Handler の戻り値** - ハンドラ関数は **必ず HandlerReturn 型** を返す
- **自動ログ** - Handler.log に基づいて EventManager._write_handler_log() で自動ログ出力
- **Handler 優先度** - `priority` パラメータで実行順序制御（高いほど先）
- **参照更新** - deepcopy 後は `update_reference()` で内部参照を新オブジェクトに付け替え
- **RoleSpec** - `"role:side"` 形式が必須（スタンドアロン値は不可）
- **派生クラス活用** - data/ 定義では AbilityHandler/ItemHandler を使い冗長さを削減
- **LogPolicy** - `"always"` (常にログ), `"on_success"` (成功時), `"on_failure"` (失敗時), `"never"` (非表示)
