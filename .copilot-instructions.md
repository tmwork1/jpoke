# Copilot 指示

## プロジェクト概要
- jpoke はポケモンシングルバトル対戦シミュレータで、戦闘ロジックの開発に使用される
- ポケモンの利用規約に抵触する可能性があるため、AI ボットの開発は保留中

## アーキテクチャ

### イベント駆動パターン
- [core/event.py](src/jpoke/core/event.py) で `EventManager` が中核。Battle の各フェーズでイベント発火
- 特性・アイテム・技の効果は `Handler` 登録で実装。同期実行、優先度制御あり
- `EventContext` で source/target/attacker/defender のロール管理
- **Handler の構造**:
  - **func**: 実行する関数（HandlerReturn を返す）
  - **subject_spec**: `"role:side"` 形式で発動条件を指定
    - role: "source", "target", "attacker", "defender"
    - side: "self"（自分側）または "foe"（相手側）
  - **source_type**: "ability" | "item" | "move"（ハンドラの出典）
  - **log**: LogPolicy で自動ログ出力の制御（"always" | "on_success" | "on_failure" | "never"）
  - プロパティ `Handler.role`, `Handler.side` で分解取得可能

### HandlerReturn
- ハンドラ関数は `HandlerReturn` NamedTuple を返す（型チェック/自動ログに使用）
- `HandlerReturn(success: bool, value: Any = None, control: HandlerResult | None = None)`
  - success: 処理が成功したか
  - value: 後続の修正計算に使う値（ダメージ補正など）
  - control: イベント制御フラグ（STOP_HANDLER など）

### Handler 派生クラス
- [handlers/ability.py](src/jpoke/handlers/ability.py): `AbilityHandler` 継承で source_type="ability" + log="on_success" デフォルト
- [handlers/item.py](src/jpoke/handlers/item.py): `ItemHandler` 継承で source_type="item" + log="on_success" デフォルト
- data 配下では派生クラスを使用し、冗長な引数指定を削減

### 主要フロー
1. **Battle.execute()** → Players の選択受け取り → ターン実行
2. **ダメージ計算** - [core/damage.py](src/jpoke/core/damage.py) で種族値・努力値・ランク・修正を集約
3. **フィールド効果** - WeatherManager, TerrainManager, SideFieldManager で状態管理
4. **深いコピー** - Battle は deepcopy 対応（乱数隠蔽含む）

### Logger の設計
- [core/logger.py](src/jpoke/core/logger.py) で `Logger` クラスが **Battle のメンバ**として存在
- **3種類のログ**:
  - `EventLog`: ターン中のイベント・アクション・メッセージ（技の使用、特性の発動など）
  - `CommandLog`: プレイヤーが選択したコマンド（リプレイ再生用）
  - `DamageLog`: ダメージ発生時の状況（将来の拡張用、現在は未実装）
- **ログのアクセス方法**:
  - Battle クラス経由: `battle.add_turn_log(source, text)` (推奨)
  - Logger 直接: `battle.logger.add_event_log(turn, idx, text)` (低レベル)
  - `source` は Player | Pokemon | list[Player] | None を受け取り、`Battle.to_player_idxes()` でインデックスに変換
- **ログの取得**: `battle.get_turn_logs(turn)` → `dict[Player, list[str]]` 形式で返す
- **命名規則**:
  - ログクラス: `XxxLog` (frozen dataclass)
  - リスト: `xxx_logs`
  - 追加メソッド: `add_xxx_log(turn, idx, text)`
  - 取得メソッド: `get_xxx_logs(turn, idx)` → 単一プレイヤーのログリスト
  - プレイヤーインデックス: `idx` (0 or 1)
- **Handler からのログ**:
  - `Handler.write_log()` が自動的に `battle.add_turn_log()` を呼び出す
  - ハンドラ内で追加ログが必要な場合: `battle.add_turn_log(pokemon, "メッセージ")`


## 命名規則
### bool 型変数・メソッド
- **状態確認**: `is_` で始める（例: `is_active`, `is_floating()`, `is_trapped()`）
- **所有確認**: `has_` で始める（例: `has_type()`, `has_interrupt()`）
- **能力確認**: `can_` で始める（例: `can_terastallize()`）

### ハンドラ関数のパラメータ命名
- ロール/サイド指定: `xxx_spec` 形式（例: `target_spec`, `source_spec`）
- `RoleSpec` 型で常に `"role:side"` 形式（例: `"target:foe"`, `"source:self"`）
- [handlers/base.py](src/jpoke/handlers/base.py) の `resolve_role()` で解決

### Logger 関連の命名
- **ログクラス**: `XxxLog` 形式（例: `EventLog`, `CommandLog`）、frozen dataclass で不変
- **ログリスト**: `xxx_logs` 形式（例: `event_logs`, `command_logs`）
- **追加メソッド**: `add_xxx_log()` 形式
- **取得メソッド**: `get_xxx_logs()` 形式（複数形）
- **インデックス**: `idx` でプレイヤーインデックス（0 or 1）を表す
- **辞書変換**: `to_dict()` でログエントリを辞書化（`dump()` は非推奨）

## 関連ファイル解読順序
1. [utils/types.py](src/jpoke/utils/types.py) - RoleSpec, EffectSource, LogPolicy などの型定義
2. [core/event.py](src/jpoke/core/event.py) - Handler, EventContext, EventManager
3. [core/battle.py](src/jpoke/core/battle.py) - Battle クラスと turn ループ
4. [data/models.py](src/jpoke/data/models.py) - AbilityData, ItemData, MoveData などの構造定義
5. [handlers/ability.py](src/jpoke/handlers/ability.py) + [handlers/item.py](src/jpoke/handlers/item.py) - Handler 派生と汎用関数

## Handler 定義パターン（data/ 配下）

Handler の定義は以下の優先順位で選択してください:

1. **名前付き関数** (最推奨): handlers/ 配下で定義し、デバッグを容易にする
2. **partial による引数固定**: handlers/common.py の汎用関数を再利用
3. **Lambda** (最小限): 単純な条件チェックのみ（複雑なロジックは禁止）

### 1. 名前付き関数の使用（最推奨）

```python
# handlers/ability.py で定義
def じりょく(battle: Battle, ctx: EventContext, value: Any):
    result = ctx.source.has_type("はがね")
    return HandlerReturn(True, result)

# data/ability.py で参照
"じりょく": AbilityData(
    handlers={
        Event.ON_CHECK_TRAPPED: h.AbilityHandler(
            h.じりょく,
            subject_spec="source:foe",
            log="never",
        )
    }
),
```

**利点**: スタックトレースで関数名表示、IDE ジャンプ可、個別テスト可

### 2. partial による引数固定

```python
"いかく": AbilityData(
    handlers={
        Event.ON_SWITCH_IN: h.AbilityHandler(
            partial(common.modify_stat, stat="A", v=-1, target_spec="source:foe"),
            subject_spec="source:self",
        )
    }
),
```

### 3. Lambda（単純な条件のみ）

```python
Event.ON_SWITCH_IN: h.AbilityHandler(
    lambda *args: HandlerReturn(True),
    subject_spec="source:self",
)
```

**注意**: 複雑なロジックを Lambda で実装すると、スタックトレースで `<lambda>` としか表示されず、デバッグが困難になります。

## テスト実行
```bash
python tests/run_tests.py              # 全テスト実行
python tests/run_tests.py "move_*.py"  # パターンマッチ
```
- [tests/run_tests.py](tests/run_tests.py) は async テストランナー
- 各ファイルで `test()` 関数を定義

## 開発時のポイント
- **Handler の戻り値** - ハンドラ関数は **必ず HandlerReturn 型** を返す
- **自動ログ** - Handler.log に基づいて EventManager._write_handler_log() で自動ログ出力
- **Handler 優先度** - `priority` パラメータで実行順序制御（デフォルト: 100）
  - priority が **小さい順**、同じなら**素早さが大きい順**に実行
  - `EventManager._sort_handlers()` で `(priority, -speed)` でソート
  - 素早さは `battle.calc_effective_speed()` で直接取得
- **参照更新** - deepcopy 後は `update_reference()` で内部参照を新オブジェクトに付け替え
- **RoleSpec** - `"role:side"` 形式が必須（スタンドアロン値は不可）
- **派生クラス活用** - data/ 定義では AbilityHandler/ItemHandler を使い冗長さを削減
- **LogPolicy** - `"always"` (常にログ), `"on_success"` (成功時), `"on_failure"` (失敗時), `"never"` (非表示)
- **デバッグ** - Lambda は `<lambda>` としか表示されないため、handlers/ で名前付き関数を定義することを推奨
